#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "aiohttp",
#     "pillow", 
#     "click",
#     "pyproj",
# ]
# ///

# ABOUTME: Canadian wildfire map scraper that downloads base map tiles and fire perimeter data for a given date
# ABOUTME: Creates composite images showing wildfire perimeters overlaid on topographic base maps using CWFIS data

import sys
import click
import aiohttp
import asyncio
from datetime import datetime
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont
from io import BytesIO
from dataclasses import dataclass

# CWFIS API endpoints - corrected URL from JavaScript source
BASE_MAP_URL = "https://geoappext.nrcan.gc.ca/arcgis/rest/services/BaseMaps/CBMT3978/MapServer/WMTS/tile/1.0.0/BaseMaps_CBMT3978/default/default028mm"
FIRE_PERIMETER_URL = "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/wms"

# Default map configuration - higher detail, extended west coverage
DEFAULT_ZOOM = 4  # Higher zoom for more detail (was 200km scale, now ~115km scale)
# Shift center west to focus on Canada landmass, reduce Atlantic Ocean coverage
DEFAULT_CENTER = (-200000, 1200000)  # Move west from 200000 to -200000
TILE_SIZE = 256
MAP_SIZE = (4, 3)  # 4 wide x 3 high - add western column for Alberta/Pacific coast

# Tile caching configuration
CACHE_DIR = Path("tile_cache")
TILE_CACHE_VERSION = "v1"  # Increment if cache format changes

@dataclass
class TileInfo:
    """Information about a tile to be downloaded and positioned."""
    col: int
    row: int
    zoom: int
    bbox: tuple[float, float, float, float]
    paste_x: int
    paste_y: int
    image_pos: tuple[int, int]  # For logging (col_idx+1, row_idx+1)

# WMTS tile grid parameters from JavaScript source (exact values)
TILE_ORIGIN = (-34655800, 39310000)  # origin: [-3.46558E7, 3.931E7]
RESOLUTIONS = [
    38364.660062653464,    # 0
    22489.62831258996,     # 1  
    13229.193125052918,    # 2
    7937.5158750317505,    # 3 <- DEFAULT_ZOOM (200km scale)
    4630.2175937685215,    # 4
    2645.8386250105837,    # 5
    1587.5031750063501,    # 6
    926.0435187537042,     # 7
    529.1677250021168,     # 8
    317.50063500127004,    # 9
    185.20870375074085,    # 10
    111.12522225044451,    # 11
    66.1459656252646,      # 12
    38.36466006265346,     # 13
    22.48962831258996,     # 14
    13.229193125052918,    # 15
    7.9375158750317505,    # 16
    4.6302175937685215     # 17
]

def validate_date(date_str: str) -> datetime:
    """Validate and parse ISO8601 date string."""
    try:
        return datetime.strptime(date_str, "%Y-%m-%d")
    except ValueError:
        raise click.BadParameter(f"Date must be in YYYY-MM-DD format, got: {date_str}")

def get_tile_cache_path(tile_col: int, tile_row: int, zoom: int) -> Path:
    """Get the cache file path for a base map tile."""
    cache_subdir = CACHE_DIR / TILE_CACHE_VERSION / f"zoom_{zoom:02d}"
    cache_subdir.mkdir(parents=True, exist_ok=True)
    return cache_subdir / f"tile_{tile_col:04d}_{tile_row:04d}.jpg"

def is_tile_cached(tile_col: int, tile_row: int, zoom: int) -> bool:
    """Check if a base map tile is already cached."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    return cache_path.exists() and cache_path.stat().st_size > 0

def load_cached_tile(tile_col: int, tile_row: int, zoom: int) -> Image.Image:
    """Load a cached base map tile."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    return Image.open(cache_path)

def save_tile_to_cache(tile_col: int, tile_row: int, zoom: int, image_data: bytes) -> None:
    """Save a base map tile to cache."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    with open(cache_path, 'wb') as f:
        f.write(image_data)

async def download_base_tile_async(session: aiohttp.ClientSession, tile_info: TileInfo) -> tuple[TileInfo, Image.Image]:
    """Download a base map tile asynchronously, using cache if available."""
    # Check cache first
    if is_tile_cached(tile_info.col, tile_info.row, tile_info.zoom):
        click.echo(f"Using cached base tile {tile_info.col},{tile_info.row}")
        image = load_cached_tile(tile_info.col, tile_info.row, tile_info.zoom)
        return tile_info, image
    
    # Download from server
    url = f"{BASE_MAP_URL}/{tile_info.zoom}/{tile_info.row}/{tile_info.col}.jpg"
    
    try:
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
            response.raise_for_status()
            content = await response.read()
            
            # Check if this is a blank tile
            blank_tile = response.headers.get('blank-tile') == 'true'
            if blank_tile:
                click.echo(f"Warning: Tile {tile_info.col},{tile_info.row} is blank (outside coverage area)", err=True)
            
            # Save to cache before processing
            save_tile_to_cache(tile_info.col, tile_info.row, tile_info.zoom, content)
            
            image = Image.open(BytesIO(content))
            click.echo(f"Downloaded and cached base tile {tile_info.col},{tile_info.row}: {len(content)} bytes, format: {image.format}")
            return tile_info, image
            
    except Exception as e:
        click.echo(f"Warning: Failed to download base tile {tile_info.col},{tile_info.row}: {e}", err=True)
        # Return blank tile
        blank_image = Image.new('RGB', (TILE_SIZE, TILE_SIZE), color='lightgray')
        return tile_info, blank_image

async def download_fire_overlay_async(session: aiohttp.ClientSession, tile_info: TileInfo, date_str: str) -> tuple[TileInfo, Image.Image]:
    """Download fire perimeter overlay for a tile asynchronously."""
    min_x, min_y, max_x, max_y = tile_info.bbox
    
    params = {
        'SERVICE': 'WMS',
        'VERSION': '1.3.0',
        'REQUEST': 'GetMap',
        'FORMAT': 'image/png',
        'TRANSPARENT': 'true',
        'LAYERS': 'public:m3_polygons',
        'CQL_FILTER': f"mindate <= '{date_str} 12:00:00' and maxdate >= '{date_str} 12:00:00'",
        'WIDTH': str(TILE_SIZE),
        'HEIGHT': str(TILE_SIZE),
        'CRS': 'EPSG:3978',
        'STYLES': '',
        'BBOX': f'{min_x},{min_y},{max_x},{max_y}'
    }
    
    try:
        async with session.get(FIRE_PERIMETER_URL, params=params, timeout=aiohttp.ClientTimeout(total=15)) as response:
            response.raise_for_status()
            content = await response.read()
            image = Image.open(BytesIO(content))
            
            # Only show success message if we got actual fire data (not just empty transparent)
            if len(content) > 1000:  # More than just a small transparent PNG
                click.echo(f"Downloaded fire overlay for tile {tile_info.col},{tile_info.row}: {len(content)} bytes")
            
            return tile_info, image
            
    except aiohttp.ClientResponseError as e:
        if e.status == 404:
            # 404 is normal - means no fire data for this tile/date
            pass
        else:
            click.echo(f"Warning: HTTP error downloading fire overlay for tile {tile_info.col},{tile_info.row}: {e}", err=True)
    except Exception as e:
        click.echo(f"Warning: Failed to download fire overlay for tile {tile_info.col},{tile_info.row}: {e}", err=True)
    
    # Return empty overlay
    empty_image = Image.new('RGBA', (TILE_SIZE, TILE_SIZE), color=(0, 0, 0, 0))
    return tile_info, empty_image

def add_date_overlay(image: Image.Image, date: datetime) -> Image.Image:
    """Add date overlay to the upper right corner of the image."""
    # Create a copy to avoid modifying the original
    img_with_overlay = image.copy()
    draw = ImageDraw.Draw(img_with_overlay)
    
    # Format the date
    date_text = date.strftime("%Y-%m-%d")
    
    # Try to use a system font, fall back to default if not available
    try:
        # Try common system fonts (adjust path as needed)
        font_size = 28  # Slightly larger for better visibility
        try:
            # macOS system font - use bold for better visibility
            font = ImageFont.truetype("/System/Library/Fonts/Arial Bold.ttf", font_size)
        except (OSError, IOError):
            try:
                # macOS fallback
                font = ImageFont.truetype("/System/Library/Fonts/Arial.ttf", font_size)
            except (OSError, IOError):
                try:
                    # Linux system font
                    font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", font_size)
                except (OSError, IOError):
                    # Windows system font
                    font = ImageFont.truetype("arial.ttf", font_size)
    except (OSError, IOError):
        # Fall back to default font if no system fonts available
        font = ImageFont.load_default()
    
    # Get text dimensions for proper positioning
    bbox = draw.textbbox((0, 0), date_text, font=font)
    text_width = bbox[2] - bbox[0]
    
    # Position in upper right corner with margin
    margin = 15
    x = img_with_overlay.width - text_width - margin
    y = margin
    
    # Draw red text with slight shadow for better contrast
    shadow_offset = 2
    # Draw shadow (dark red)
    draw.text((x + shadow_offset, y + shadow_offset), date_text, fill=(100, 0, 0), font=font)
    # Draw main text (bright red)
    draw.text((x, y), date_text, fill=(255, 50, 50), font=font)
    
    return img_with_overlay

def epsg3978_to_tile(x: float, y: float, zoom: int) -> tuple[int, int]:
    """Convert EPSG:3978 coordinates to tile coordinates using WMTS grid calculation."""
    if zoom >= len(RESOLUTIONS):
        raise ValueError(f"Zoom level {zoom} not supported, max is {len(RESOLUTIONS)-1}")
    
    resolution = RESOLUTIONS[zoom]
    origin_x, origin_y = TILE_ORIGIN
    
    # WMTS tile grid calculation
    # TileCol (X): how many tiles east from origin
    tile_col = int((x - origin_x) / (resolution * TILE_SIZE))
    
    # TileRow (Y): how many tiles south from origin  
    tile_row = int((origin_y - y) / (resolution * TILE_SIZE))
    
    return tile_col, tile_row

def tile_to_epsg3978_bbox(tile_col: int, tile_row: int, zoom: int) -> tuple[float, float, float, float]:
    """Convert tile coordinates to EPSG:3978 bounding box using WMTS grid calculation."""
    if zoom >= len(RESOLUTIONS):
        raise ValueError(f"Zoom level {zoom} not supported, max is {len(RESOLUTIONS)-1}")
    
    resolution = RESOLUTIONS[zoom]
    origin_x, origin_y = TILE_ORIGIN
    tile_size_map_units = resolution * TILE_SIZE
    
    # Calculate tile bounds
    min_x = origin_x + (tile_col * tile_size_map_units)
    max_x = min_x + tile_size_map_units
    max_y = origin_y - (tile_row * tile_size_map_units)
    min_y = max_y - tile_size_map_units
    
    return min_x, min_y, max_x, max_y


async def create_wildfire_map(date: datetime, output_path: Path, zoom: int = DEFAULT_ZOOM, map_size: tuple[int, int] = MAP_SIZE, date_overlay: bool = True) -> None:
    """Create a wildfire map for the given date using async downloads."""
    date_str = date.strftime("%Y-%m-%d")
    click.echo(f"Creating wildfire map for {date_str}...")
    click.echo(f"Configuration: zoom={zoom}, map_size={map_size[0]}x{map_size[1]} tiles")
    
    # Calculate tile grid around default center
    center_x, center_y = DEFAULT_CENTER
    center_tile_col, center_tile_row = epsg3978_to_tile(center_x, center_y, zoom)
    
    # Calculate tile bounds for map coverage
    tiles_wide, tiles_high = map_size
    start_tile_col = center_tile_col - tiles_wide // 2
    start_tile_row = center_tile_row - tiles_high // 2
    
    click.echo(f"Downloading {tiles_wide}x{tiles_high} tiles centered on tile {center_tile_col},{center_tile_row}")
    click.echo(f"Tile range: col {start_tile_col} to {start_tile_col + tiles_wide - 1}, row {start_tile_row} to {start_tile_row + tiles_high - 1}")
    
    # Prepare all tile requests upfront
    tile_requests = []
    for row_idx in range(tiles_high):
        for col_idx in range(tiles_wide):
            tile_col = start_tile_col + col_idx
            tile_row = start_tile_row + row_idx
            bbox = tile_to_epsg3978_bbox(tile_col, tile_row, zoom)
            
            tile_info = TileInfo(
                col=tile_col,
                row=tile_row,
                zoom=zoom,
                bbox=bbox,
                paste_x=col_idx * TILE_SIZE,
                paste_y=row_idx * TILE_SIZE,
                image_pos=(col_idx+1, row_idx+1)
            )
            tile_requests.append(tile_info)
    
    # Create final image
    final_width = tiles_wide * TILE_SIZE
    final_height = tiles_high * TILE_SIZE
    final_image = Image.new('RGB', (final_width, final_height))
    
    # Configure connection limits for server kindness
    connector = aiohttp.TCPConnector(
        limit=100,           # Total connection pool size
        limit_per_host=8,    # Max connections per host
        ttl_dns_cache=300    # DNS cache TTL
    )
    
    # Download all tiles concurrently
    async with aiohttp.ClientSession(connector=connector) as session:
        click.echo("Starting concurrent downloads...")
        
        # Download base tiles and fire overlays concurrently
        base_tasks = [download_base_tile_async(session, tile_info) for tile_info in tile_requests]
        fire_tasks = [download_fire_overlay_async(session, tile_info, date_str) for tile_info in tile_requests]
        
        # Wait for all downloads to complete (maintains order!)
        base_results = await asyncio.gather(*base_tasks)
        fire_results = await asyncio.gather(*fire_tasks)
    
    # Composite results in order
    click.echo("Compositing tiles...")
    for (tile_info, base_tile), (_, fire_overlay) in zip(base_results, fire_results):
        click.echo(f"  -> Placing tile col={tile_info.col}, row={tile_info.row} at position {tile_info.paste_x},{tile_info.paste_y}")
        
        # Composite base and overlay
        if fire_overlay.mode == 'RGBA':
            base_tile = base_tile.convert('RGBA')
            composite = Image.alpha_composite(base_tile, fire_overlay)
            composite = composite.convert('RGB')
        else:
            composite = base_tile
        
        # Place in final image
        final_image.paste(composite, (tile_info.paste_x, tile_info.paste_y))
    
    # Add date overlay if requested
    if date_overlay:
        click.echo("Adding date overlay...")
        final_image = add_date_overlay(final_image, date)
    
    # Save final image
    final_image.save(output_path, 'PNG', optimize=True)
    click.echo(f"Wildfire map saved to: {output_path}")
    click.echo(f"Image size: {final_width}x{final_height} pixels")


@click.command()
@click.argument('date', callback=lambda ctx, param, value: validate_date(value))
@click.option('--output', '-o', type=click.Path(), help='Output filename (default: wildfire-YYYY-MM-DD-zZ-WxH.png)')
@click.option('--zoom', '-z', type=int, default=DEFAULT_ZOOM, help=f'Zoom level (0-{len(RESOLUTIONS)-1}, default: {DEFAULT_ZOOM})')
@click.option('--width', '-w', type=int, default=MAP_SIZE[0], help=f'Map width in tiles (default: {MAP_SIZE[0]})')
@click.option('--height', '-h', type=int, default=MAP_SIZE[1], help=f'Map height in tiles (default: {MAP_SIZE[1]})')
@click.option('--date-overlay/--no-date-overlay', default=True, help='Add date overlay to upper right corner (default: enabled)')
def main(date: datetime, output: str = None, zoom: int = DEFAULT_ZOOM, width: int = MAP_SIZE[0], height: int = MAP_SIZE[1], date_overlay: bool = True) -> None:
    """
    Download Canadian wildfire map for a given date using async downloads with connection pooling.
    
    DATE: Date in YYYY-MM-DD format (e.g., 2025-08-04)
    
    Examples:
        wildfire 2025-08-04                           # Default: zoom 4, 4x3 tiles, with date overlay
        wildfire 2025-08-04 -z 5 -w 5 -h 4           # Custom zoom and size
        wildfire 2025-08-04 --no-date-overlay         # Disable date overlay
        wildfire 2025-08-04 -z 3 -w 6 -h 3 -o big.png # Custom output filename
    """
    # Validate parameters
    if zoom < 0 or zoom >= len(RESOLUTIONS):
        click.echo(f"Error: Zoom level must be between 0 and {len(RESOLUTIONS)-1}, got {zoom}", err=True)
        sys.exit(1)
    
    if width < 1 or width > 10:
        click.echo(f"Error: Width must be between 1 and 10 tiles, got {width}", err=True)
        sys.exit(1)
    
    if height < 1 or height > 10:
        click.echo(f"Error: Height must be between 1 and 10 tiles, got {height}", err=True)
        sys.exit(1)
    
    if output is None:
        output = f"wildfire-{date.strftime('%Y-%m-%d')}-z{zoom}-{width}x{height}.png"
    
    output_path = Path(output)
    
    try:
        asyncio.run(create_wildfire_map(date, output_path, zoom, (width, height), date_overlay))
    except KeyboardInterrupt:
        click.echo("\nOperation cancelled by user", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)

if __name__ == '__main__':
    main()