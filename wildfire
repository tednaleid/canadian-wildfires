#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "requests",
#     "pillow", 
#     "click",
#     "pyproj",
# ]
# ///

# ABOUTME: Canadian wildfire map scraper that downloads base map tiles and fire perimeter data for a given date
# ABOUTME: Creates composite images showing wildfire perimeters overlaid on topographic base maps using CWFIS data

import sys
import click
import requests
from datetime import datetime
from pathlib import Path
import math
from PIL import Image, ImageDraw
from io import BytesIO
from urllib.parse import urlencode
import time

# CWFIS API endpoints
BASE_MAP_URL = "https://maps-cartes.services.geo.ca/server2_serveur2/rest/services/BaseMaps/CBMT3978/MapServer/WMTS/tile/1.0.0/BaseMaps_CBMT3978/default/default028mm"
FIRE_PERIMETER_URL = "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/wms"

# Default map configuration (to match actual browser behavior)
DEFAULT_ZOOM = 4  # Browser uses zoom 4 for base tiles
DEFAULT_CENTER = (400000, 1000000)  # Browser's actual center coordinates
TILE_SIZE = 256
MAP_SIZE = (4, 3)  # tiles (width, height) for reasonable coverage

# WMTS tile grid parameters from OpenLayers (layer0)
TILE_ORIGIN = (-34655800, 39310000)  # Upper-left origin
RESOLUTIONS = [
    38364.660062653464, 22489.62831258996, 13229.193125052918, 7937.5158750317505,
    4630.2175937685215, 2645.8386250105837, 1587.5031750063501, 926.0435187537042,
    529.1677250021168, 317.50063500127004, 185.20870375074085, 111.12522225044451,
    66.1459656252646, 38.36466006265346, 22.48962831258996, 13.229193125052918,
    7.9375158750317505, 4.6302175937685215
]

def validate_date(date_str: str) -> datetime:
    """Validate and parse ISO8601 date string."""
    try:
        return datetime.strptime(date_str, "%Y-%m-%d")
    except ValueError:
        raise click.BadParameter(f"Date must be in YYYY-MM-DD format, got: {date_str}")

def epsg3978_to_tile(x: float, y: float, zoom: int) -> tuple[int, int]:
    """Convert EPSG:3978 coordinates to tile coordinates using browser-observed mapping."""
    # Hard-code the relationship observed from browser: center (400000, 1000000) -> tile (31.5, 29.5)
    if zoom == 4:
        # Browser shows tiles 30-33, 27-32, so center is around (31.5, 29.5) 
        center_epsg_x, center_epsg_y = 400000, 1000000
        center_tile_x, center_tile_y = 31.5, 29.5
        
        # Estimate scale: tiles are ~1.587M EPSG units wide at zoom 4 based on browser bboxes
        tile_size_epsg = 1587500  # From browser BBOX differences
        
        # Calculate tile offset from center
        offset_x = (x - center_epsg_x) / tile_size_epsg
        offset_y = (center_epsg_y - y) / tile_size_epsg  # Y is flipped
        
        tile_x = int(center_tile_x + offset_x)
        tile_y = int(center_tile_y + offset_y)
        
        return tile_x, tile_y
    else:
        raise ValueError(f"Only zoom level 4 is supported, got {zoom}")

def tile_to_epsg3978_bbox(tile_x: int, tile_y: int, zoom: int) -> tuple[float, float, float, float]:
    """Convert tile coordinates to EPSG:3978 bounding box using browser-observed mapping."""
    if zoom == 4:
        # Use the same mapping as epsg3978_to_tile but in reverse
        center_epsg_x, center_epsg_y = 400000, 1000000
        center_tile_x, center_tile_y = 31.5, 29.5
        tile_size_epsg = 1587500
        
        # Calculate tile center
        offset_x = (tile_x - center_tile_x) * tile_size_epsg
        offset_y = (center_tile_y - tile_y) * tile_size_epsg  # Y is flipped
        
        tile_center_x = center_epsg_x + offset_x
        tile_center_y = center_epsg_y + offset_y
        
        # Calculate bbox (tile extends half tile_size in each direction)
        half_tile = tile_size_epsg / 2
        min_x = tile_center_x - half_tile
        max_x = tile_center_x + half_tile
        min_y = tile_center_y - half_tile
        max_y = tile_center_y + half_tile
        
        return min_x, min_y, max_x, max_y
    else:
        raise ValueError(f"Only zoom level 4 is supported, got {zoom}")

def download_base_tile(tile_x: int, tile_y: int, zoom: int) -> Image.Image:
    """Download a base map tile."""
    url = f"{BASE_MAP_URL}/{zoom}/{tile_x}/{tile_y}.jpg"
    
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        
        # Check if this is a blank tile
        blank_tile = response.headers.get('blank-tile') == 'true'
        if blank_tile:
            click.echo(f"Warning: Tile {tile_x},{tile_y} is blank (outside coverage area)", err=True)
        
        image = Image.open(BytesIO(response.content))
        click.echo(f"Downloaded base tile {tile_x},{tile_y}: {len(response.content)} bytes, format: {image.format}")
        return image
    except Exception as e:
        click.echo(f"Warning: Failed to download base tile {tile_x},{tile_y}: {e}", err=True)
        # Return blank tile
        return Image.new('RGB', (TILE_SIZE, TILE_SIZE), color='lightgray')

def download_fire_overlay(bbox: tuple[float, float, float, float], date_str: str) -> Image.Image:
    """Download fire perimeter overlay for a tile."""
    min_x, min_y, max_x, max_y = bbox
    
    params = {
        'SERVICE': 'WMS',
        'VERSION': '1.3.0',
        'REQUEST': 'GetMap',
        'FORMAT': 'image/png',
        'TRANSPARENT': 'true',
        'LAYERS': 'public:m3_polygons',
        'CQL_FILTER': f"mindate <= '{date_str} 12:00:00' and maxdate >= '{date_str} 12:00:00'",
        'WIDTH': str(TILE_SIZE),
        'HEIGHT': str(TILE_SIZE),
        'CRS': 'EPSG:3978',
        'STYLES': '',
        'BBOX': f'{min_x},{min_y},{max_x},{max_y}'
    }
    
    url = f"{FIRE_PERIMETER_URL}?{urlencode(params)}"
    
    try:
        response = requests.get(url, timeout=15)
        response.raise_for_status()
        image = Image.open(BytesIO(response.content))
        # Only show success message if we got actual fire data (not just empty transparent)
        if len(response.content) > 1000:  # More than just a small transparent PNG
            click.echo(f"Downloaded fire overlay: {len(response.content)} bytes")
        return image
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            # 404 is normal - means no fire data for this tile/date
            pass
        else:
            click.echo(f"Warning: HTTP error downloading fire overlay: {e}", err=True)
        return Image.new('RGBA', (TILE_SIZE, TILE_SIZE), color=(0, 0, 0, 0))
    except Exception as e:
        click.echo(f"Warning: Failed to download fire overlay: {e}", err=True)
        return Image.new('RGBA', (TILE_SIZE, TILE_SIZE), color=(0, 0, 0, 0))

def create_wildfire_map(date: datetime, output_path: Path) -> None:
    """Create a wildfire map for the given date."""
    date_str = date.strftime("%Y-%m-%d")
    click.echo(f"Creating wildfire map for {date_str}...")
    
    # Calculate tile grid around default center
    center_x, center_y = DEFAULT_CENTER
    center_tile_x, center_tile_y = epsg3978_to_tile(center_x, center_y, DEFAULT_ZOOM)
    
    # Calculate tile bounds for map coverage
    tiles_wide, tiles_high = MAP_SIZE
    start_tile_x = center_tile_x - tiles_wide // 2
    start_tile_y = center_tile_y - tiles_high // 2
    
    click.echo(f"Downloading {tiles_wide}x{tiles_high} tiles centered on tile {center_tile_x},{center_tile_y}")
    
    # Create final image
    final_width = tiles_wide * TILE_SIZE
    final_height = tiles_high * TILE_SIZE
    final_image = Image.new('RGB', (final_width, final_height))
    
    # Download and composite tiles
    # Note: tile_x represents north-south (increasing x = more south)  
    # Note: tile_y represents west-east (increasing y = more east)
    for ty in range(tiles_high):
        for tx in range(tiles_wide):
            tile_x = start_tile_x + ty  # ty maps to north-south (tile_x)
            tile_y = start_tile_y + tx  # tx maps to west-east (tile_y)
            
            click.echo(f"Processing tile {tx+1},{ty+1} of {tiles_wide},{tiles_high} (tile coords: {tile_x},{tile_y})")
            
            # Download base tile
            base_tile = download_base_tile(tile_x, tile_y, DEFAULT_ZOOM)
            
            # Download fire overlay
            bbox = tile_to_epsg3978_bbox(tile_x, tile_y, DEFAULT_ZOOM)
            fire_overlay = download_fire_overlay(bbox, date_str)
            
            # Composite base and overlay
            if fire_overlay.mode == 'RGBA':
                base_tile = base_tile.convert('RGBA')
                composite = Image.alpha_composite(base_tile, fire_overlay)
                composite = composite.convert('RGB')
            else:
                composite = base_tile
            
            # Place in final image - tx=horizontal, ty=vertical in final image
            paste_x = tx * TILE_SIZE
            paste_y = ty * TILE_SIZE
            click.echo(f"  -> Placing tile {tile_x},{tile_y} at position {paste_x},{paste_y} in final image")
            final_image.paste(composite, (paste_x, paste_y))
            
            # Brief delay to be respectful to servers
            time.sleep(0.1)
    
    # Save final image
    final_image.save(output_path, 'PNG', optimize=True)
    click.echo(f"Wildfire map saved to: {output_path}")
    click.echo(f"Image size: {final_width}x{final_height} pixels")

@click.command()
@click.argument('date', callback=lambda ctx, param, value: validate_date(value))
@click.option('--output', '-o', type=click.Path(), help='Output filename (default: wildfire-YYYY-MM-DD.png)')
def main(date: datetime, output: str = None) -> None:
    """
    Download Canadian wildfire map for a given date.
    
    DATE: Date in YYYY-MM-DD format (e.g., 2025-08-04)
    
    Example:
        wildfire 2025-08-04
    """
    if output is None:
        output = f"wildfire-{date.strftime('%Y-%m-%d')}.png"
    
    output_path = Path(output)
    
    try:
        create_wildfire_map(date, output_path)
    except KeyboardInterrupt:
        click.echo("\nOperation cancelled by user", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)

if __name__ == '__main__':
    main()