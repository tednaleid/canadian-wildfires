#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "aiohttp",
#     "pillow", 
#     "click",
#     "pyproj",
#     "numpy",
# ]
# ///

# ABOUTME: Canadian wildfire map scraper that downloads base map tiles and fire perimeter data for a given date
# ABOUTME: Creates composite images showing wildfire perimeters overlaid on topographic base maps using CWFIS data

import sys
import click
import aiohttp
import asyncio
from datetime import datetime, timedelta
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont
from io import BytesIO
from dataclasses import dataclass
import numpy as np

# CWFIS API endpoints
BASE_MAP_URL = "https://geoappext.nrcan.gc.ca/arcgis/rest/services/BaseMaps/CBMT3978/MapServer/WMTS/tile/1.0.0/BaseMaps_CBMT3978/default/default028mm"
FIRE_PERIMETER_URL = "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/wms"

# Default map configuration
DEFAULT_ZOOM = 4  # Zoom level 4 provides ~115km scale
DEFAULT_CENTER = (-200000, 600000)  # Center focused on Canadian landmass
TILE_SIZE = 256
MAP_SIZE = (4, 3)  # 4 tiles wide x 3 tiles high for optimal coverage

# Tile caching configuration
CACHE_DIR = Path("tile_cache")
TILE_CACHE_VERSION = "v1"  # Increment if cache format changes

# Fire overlay caching configuration
FIRE_CACHE_DIR = Path("fire_cache")
FIRE_CACHE_VERSION = "v1"  # Increment if cache format changes

@dataclass
class TileInfo:
    """Information about a tile to be downloaded and positioned."""
    col: int
    row: int
    zoom: int
    bbox: tuple[float, float, float, float]
    paste_x: int
    paste_y: int
    image_pos: tuple[int, int]  # For logging (col_idx+1, row_idx+1)

# WMTS tile grid parameters
TILE_ORIGIN = (-34655800, 39310000)  # Upper-left origin point
RESOLUTIONS = [
    38364.660062653464,    # 0
    22489.62831258996,     # 1  
    13229.193125052918,    # 2
    7937.5158750317505,    # 3
    4630.2175937685215,    # 4
    2645.8386250105837,    # 5
    1587.5031750063501,    # 6
    926.0435187537042,     # 7
    529.1677250021168,     # 8
    317.50063500127004,    # 9
    185.20870375074085,    # 10
    111.12522225044451,    # 11
    66.1459656252646,      # 12
    38.36466006265346,     # 13
    22.48962831258996,     # 14
    13.229193125052918,    # 15
    7.9375158750317505,    # 16
    4.6302175937685215     # 17
]

def validate_date(date_str: str) -> datetime:
    """Validate and parse ISO8601 date string."""
    try:
        return datetime.strptime(date_str, "%Y-%m-%d")
    except ValueError:
        raise click.BadParameter(f"Date must be in YYYY-MM-DD format, got: {date_str}")

def get_tile_cache_path(tile_col: int, tile_row: int, zoom: int) -> Path:
    """Get the cache file path for a base map tile."""
    cache_subdir = CACHE_DIR / TILE_CACHE_VERSION / f"zoom_{zoom:02d}"
    cache_subdir.mkdir(parents=True, exist_ok=True)
    return cache_subdir / f"tile_{tile_col:04d}_{tile_row:04d}.jpg"

def is_tile_cached(tile_col: int, tile_row: int, zoom: int) -> bool:
    """Check if a base map tile is already cached."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    return cache_path.exists() and cache_path.stat().st_size > 0

def load_cached_tile(tile_col: int, tile_row: int, zoom: int) -> Image.Image:
    """Load a cached base map tile."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    return Image.open(cache_path)

def save_tile_to_cache(tile_col: int, tile_row: int, zoom: int, image_data: bytes) -> None:
    """Save a base map tile to cache."""
    cache_path = get_tile_cache_path(tile_col, tile_row, zoom)
    with open(cache_path, 'wb') as f:
        f.write(image_data)

def get_fire_cache_path(tile_col: int, tile_row: int, zoom: int, date: datetime) -> Path:
    """Get the cache file path for a fire overlay."""
    # Organize by year/month for better file management
    year_month = date.strftime("%Y/%m")
    date_str = date.strftime("%Y-%m-%d")
    
    cache_subdir = FIRE_CACHE_DIR / FIRE_CACHE_VERSION / year_month / f"zoom_{zoom:02d}"
    cache_subdir.mkdir(parents=True, exist_ok=True)
    return cache_subdir / f"fire_{date_str}_tile_{tile_col:04d}_{tile_row:04d}.png"

def is_fire_cached(tile_col: int, tile_row: int, zoom: int, date: datetime) -> bool:
    """Check if a fire overlay is already cached."""
    cache_path = get_fire_cache_path(tile_col, tile_row, zoom, date)
    return cache_path.exists() and cache_path.stat().st_size > 0

def load_cached_fire(tile_col: int, tile_row: int, zoom: int, date: datetime) -> Image.Image:
    """Load a cached fire overlay."""
    cache_path = get_fire_cache_path(tile_col, tile_row, zoom, date)
    return Image.open(cache_path)

def save_fire_to_cache(tile_col: int, tile_row: int, zoom: int, date: datetime, image_data: bytes) -> None:
    """Save a fire overlay to cache."""
    cache_path = get_fire_cache_path(tile_col, tile_row, zoom, date)
    with open(cache_path, 'wb') as f:
        f.write(image_data)

def colorize_fire_overlay(image: Image.Image, year: int, min_year: int, max_year: int) -> Image.Image:
    """
    Convert fire overlay from pink to a color based on year.
    Older years are grey, newer years are progressively more red.
    """
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Convert to numpy array for easier manipulation
    data = np.array(image)
    
    # Extract alpha channel
    alpha = data[:, :, 3]
    
    # Create mask for non-transparent pixels
    mask = alpha > 0
    
    if not np.any(mask):
        # No fire data in this image
        return image
    
    # Calculate color based on year position
    if min_year == max_year:
        # Single year - use red
        factor = 1.0
    else:
        # Multiple years - gradient from grey to red
        year_range = max_year - min_year
        year_position = year - min_year
        
        if year == max_year:
            # Current year - make it pop with bright red
            factor = 1.0
        else:
            # Previous years - use non-linear gradient that stays more grey
            # Use a power function to keep values lower (more grey) for most of the range
            linear_factor = year_position / year_range
            # Cube the factor to make it grow slowly at first, then faster near the end
            # This keeps older years more grey
            factor = linear_factor ** 3 * 0.7  # Max out at 0.7 for non-current years
    
    # Create new color
    # Grey: RGB(128, 128, 128) to Red: RGB(255, 0, 0)
    # Interpolate between grey and red based on factor
    red = int(128 + 127 * factor)  # 128 to 255
    green = int(128 * (1 - factor))  # 128 to 0
    blue = int(128 * (1 - factor))   # 128 to 0
    
    # Apply new color to non-transparent pixels
    data[mask, 0] = red
    data[mask, 1] = green
    data[mask, 2] = blue
    # Keep alpha channel unchanged
    
    # Convert back to PIL Image
    return Image.fromarray(data)

async def download_base_tile_async(session: aiohttp.ClientSession, tile_info: TileInfo) -> tuple[TileInfo, Image.Image]:
    """Download a base map tile with caching support."""
    # Check cache first
    if is_tile_cached(tile_info.col, tile_info.row, tile_info.zoom):
        click.echo(f"Using cached base tile {tile_info.col},{tile_info.row}")
        image = load_cached_tile(tile_info.col, tile_info.row, tile_info.zoom)
        return tile_info, image
    
    # Download from server
    url = f"{BASE_MAP_URL}/{tile_info.zoom}/{tile_info.row}/{tile_info.col}.jpg"
    
    try:
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
            response.raise_for_status()
            content = await response.read()
            
            # Check if this is a blank tile
            blank_tile = response.headers.get('blank-tile') == 'true'
            if blank_tile:
                click.echo(f"Warning: Tile {tile_info.col},{tile_info.row} is blank (outside coverage area)", err=True)
            
            # Save to cache before processing
            save_tile_to_cache(tile_info.col, tile_info.row, tile_info.zoom, content)
            
            image = Image.open(BytesIO(content))
            click.echo(f"Downloaded and cached base tile {tile_info.col},{tile_info.row}: {len(content)} bytes, format: {image.format}")
            return tile_info, image
            
    except Exception as e:
        click.echo(f"Warning: Failed to download base tile {tile_info.col},{tile_info.row}: {e}", err=True)
        # Return blank tile
        blank_image = Image.new('RGB', (TILE_SIZE, TILE_SIZE), color='lightgray')
        return tile_info, blank_image

async def download_fire_overlay_async(session: aiohttp.ClientSession, tile_info: TileInfo, date: datetime, year_range: tuple[int, int] = None) -> tuple[TileInfo, Image.Image]:
    """Download fire perimeter overlay for a tile with caching support and optional year-based coloring."""
    # Check cache first
    if is_fire_cached(tile_info.col, tile_info.row, tile_info.zoom, date):
        click.echo(f"Using cached fire overlay {tile_info.col},{tile_info.row} for {date.strftime('%Y-%m-%d')}")
        image = load_cached_fire(tile_info.col, tile_info.row, tile_info.zoom, date)
        
        # Apply year-based coloring if year_range is provided
        if year_range:
            min_year, max_year = year_range
            image = colorize_fire_overlay(image, date.year, min_year, max_year)
        
        return tile_info, image
    
    # Download from server
    min_x, min_y, max_x, max_y = tile_info.bbox
    date_str = date.strftime("%Y-%m-%d")
    
    params = {
        'SERVICE': 'WMS',
        'VERSION': '1.3.0',
        'REQUEST': 'GetMap',
        'FORMAT': 'image/png',
        'TRANSPARENT': 'true',
        'LAYERS': 'public:m3_polygons',
        'CQL_FILTER': f"mindate <= '{date_str} 12:00:00' and maxdate >= '{date_str} 12:00:00'",
        'WIDTH': str(TILE_SIZE),
        'HEIGHT': str(TILE_SIZE),
        'CRS': 'EPSG:3978',
        'STYLES': '',
        'BBOX': f'{min_x},{min_y},{max_x},{max_y}'
    }
    
    try:
        async with session.get(FIRE_PERIMETER_URL, params=params, timeout=aiohttp.ClientTimeout(total=15)) as response:
            response.raise_for_status()
            content = await response.read()
            image = Image.open(BytesIO(content))
            
            # Save to cache (always cache, even empty responses to avoid repeat requests)
            save_fire_to_cache(tile_info.col, tile_info.row, tile_info.zoom, date, content)
            
            # Only show success message if we got actual fire data (not just empty transparent)
            if len(content) > 1000:  # More than just a small transparent PNG
                click.echo(f"Downloaded and cached fire overlay for tile {tile_info.col},{tile_info.row}: {len(content)} bytes")
            else:
                click.echo(f"Downloaded and cached empty fire overlay for tile {tile_info.col},{tile_info.row}")
            
            # Apply year-based coloring if year_range is provided
            if year_range:
                min_year, max_year = year_range
                image = colorize_fire_overlay(image, date.year, min_year, max_year)
            
            return tile_info, image
            
    except aiohttp.ClientResponseError as e:
        if e.status == 404:
            # 404 is normal - means no fire data for this tile/date
            pass
        else:
            click.echo(f"Warning: HTTP error downloading fire overlay for tile {tile_info.col},{tile_info.row}: {e}", err=True)
    except Exception as e:
        click.echo(f"Warning: Failed to download fire overlay for tile {tile_info.col},{tile_info.row}: {e}", err=True)
    
    # Return empty overlay
    empty_image = Image.new('RGBA', (TILE_SIZE, TILE_SIZE), color=(0, 0, 0, 0))
    return tile_info, empty_image

def add_date_overlay(image: Image.Image, date: datetime, year_range: tuple[int, int] = None) -> Image.Image:
    """Add date overlay to the upper right corner of the image."""
    # Create a copy to avoid modifying the original
    img_with_overlay = image.copy()
    
    # Try to use a system font, fall back to default if not available
    try:
        # Try common system fonts (adjust path as needed)
        font_size = 96  
        try:
            # macOS system font - use bold for better visibility
            font = ImageFont.truetype("/System/Library/Fonts/Arial Bold.ttf", font_size)
        except (OSError, IOError):
            try:
                # macOS fallback
                font = ImageFont.truetype("/System/Library/Fonts/Arial.ttf", font_size)
            except (OSError, IOError):
                try:
                    # Linux system font
                    font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", font_size)
                except (OSError, IOError):
                    # Windows system font
                    font = ImageFont.truetype("arial.ttf", font_size)
    except (OSError, IOError):
        # Fall back to default font if no system fonts available
        font = ImageFont.load_default()
    
    # Position in upper right corner with margin
    margin = 15
    y = margin
    
    if year_range:
        # For multi-year overlays, create color-coded year range
        start_year, end_year = year_range
        month_day = date.strftime('%m-%d')
        
        # Create a new image with RGBA mode for transparency support
        overlay_img = Image.new('RGBA', img_with_overlay.size, (0, 0, 0, 0))
        draw = ImageDraw.Draw(overlay_img)
        
        # Calculate positions for each part
        start_year_text = str(start_year)
        end_year_text = str(end_year)
        dash_text = "-"
        
        # Get text widths
        start_bbox = draw.textbbox((0, 0), start_year_text, font=font)
        dash_bbox = draw.textbbox((0, 0), dash_text, font=font)
        end_bbox = draw.textbbox((0, 0), end_year_text, font=font)
        month_bbox = draw.textbbox((0, 0), " " + month_day, font=font)
        
        total_width = (start_bbox[2] - start_bbox[0]) + (dash_bbox[2] - dash_bbox[0]) + \
                      (end_bbox[2] - end_bbox[0]) + (month_bbox[2] - month_bbox[0])
        
        x = img_with_overlay.width - total_width - margin
        
        # Draw start year (grey with black outline)
        current_x = x
        # Black outline (less dark)
        for offset_x in range(-2, 3):
            for offset_y in range(-2, 3):
                if offset_x != 0 or offset_y != 0:
                    draw.text((current_x + offset_x, y + offset_y), start_year_text, 
                             fill=(0, 0, 0, 120), font=font)
        # Grey text (semi-transparent)
        draw.text((current_x, y), start_year_text, fill=(128, 128, 128, 180), font=font)
        current_x += start_bbox[2] - start_bbox[0]
        
        # Draw dash (intermediate red with dark outline)
        # Dark outline (less dark)
        for offset_x in range(-2, 3):
            for offset_y in range(-2, 3):
                if offset_x != 0 or offset_y != 0:
                    draw.text((current_x + offset_x, y + offset_y), dash_text, 
                             fill=(64, 0, 0, 130), font=font)  # Less dark outline
        # Intermediate red color (between grey and bright red)
        draw.text((current_x, y), dash_text, fill=(192, 64, 64, 190), font=font)
        current_x += dash_bbox[2] - dash_bbox[0]
        
        # Draw end year (red with bright red outline)
        # Bright red outline (not quite #FF0000 but close)
        for offset_x in range(-2, 3):
            for offset_y in range(-2, 3):
                if offset_x != 0 or offset_y != 0:
                    draw.text((current_x + offset_x, y + offset_y), end_year_text, 
                             fill=(220, 0, 0, 230), font=font)  # Bright red outline
        # Red text (semi-transparent)
        draw.text((current_x, y), end_year_text, fill=(255, 50, 50, 200), font=font)
        current_x += end_bbox[2] - end_bbox[0]
        
        # Draw month-day (grey like start year)
        # Black outline (less dark)
        for offset_x in range(-2, 3):
            for offset_y in range(-2, 3):
                if offset_x != 0 or offset_y != 0:
                    draw.text((current_x + offset_x, y + offset_y), " " + month_day, 
                             fill=(0, 0, 0, 120), font=font)
        # Grey text
        draw.text((current_x, y), " " + month_day, fill=(128, 128, 128, 180), font=font)
        
        # Composite the overlay onto the main image
        img_with_overlay = Image.alpha_composite(img_with_overlay.convert('RGBA'), overlay_img).convert('RGB')
        
    else:
        # Single year - use original red text with white outline
        draw = ImageDraw.Draw(img_with_overlay)
        date_text = date.strftime("%Y-%m-%d")
        
        # Get text dimensions
        bbox = draw.textbbox((0, 0), date_text, font=font)
        text_width = bbox[2] - bbox[0]
        x = img_with_overlay.width - text_width - margin
        
        # Draw white outline
        for offset_x in range(-2, 3):
            for offset_y in range(-2, 3):
                if offset_x != 0 or offset_y != 0:
                    draw.text((x + offset_x, y + offset_y), date_text, fill=(255, 255, 255), font=font)
        
        # Draw main text (bright red) on top
        draw.text((x, y), date_text, fill=(255, 50, 50), font=font)
    
    return img_with_overlay

def epsg3978_to_tile(x: float, y: float, zoom: int) -> tuple[int, int]:
    """Convert EPSG:3978 coordinates to tile coordinates."""
    if zoom >= len(RESOLUTIONS):
        raise ValueError(f"Zoom level {zoom} not supported, max is {len(RESOLUTIONS)-1}")
    
    resolution = RESOLUTIONS[zoom]
    origin_x, origin_y = TILE_ORIGIN
    
    # WMTS tile grid calculation
    # TileCol (X): how many tiles east from origin
    tile_col = int((x - origin_x) / (resolution * TILE_SIZE))
    
    # TileRow (Y): how many tiles south from origin  
    tile_row = int((origin_y - y) / (resolution * TILE_SIZE))
    
    return tile_col, tile_row

def tile_to_epsg3978_bbox(tile_col: int, tile_row: int, zoom: int) -> tuple[float, float, float, float]:
    """Convert tile coordinates to EPSG:3978 bounding box."""
    if zoom >= len(RESOLUTIONS):
        raise ValueError(f"Zoom level {zoom} not supported, max is {len(RESOLUTIONS)-1}")
    
    resolution = RESOLUTIONS[zoom]
    origin_x, origin_y = TILE_ORIGIN
    tile_size_map_units = resolution * TILE_SIZE
    
    # Calculate tile bounds
    min_x = origin_x + (tile_col * tile_size_map_units)
    max_x = min_x + tile_size_map_units
    max_y = origin_y - (tile_row * tile_size_map_units)
    min_y = max_y - tile_size_map_units
    
    return min_x, min_y, max_x, max_y


async def create_wildfire_map(date: datetime, output_path: Path, zoom: int = DEFAULT_ZOOM, map_size: tuple[int, int] = MAP_SIZE, date_overlay: bool = True, year_range: tuple[int, int] = None) -> None:
    """Create a wildfire map for the given date."""
    if year_range:
        start_year, end_year = year_range
        date_str = f"{start_year}-{end_year} {date.strftime('%m-%d')}"
    else:
        date_str = date.strftime("%Y-%m-%d")
    click.echo(f"Creating wildfire map for {date_str}...")
    click.echo(f"Configuration: zoom={zoom}, map_size={map_size[0]}x{map_size[1]} tiles")
    
    # Calculate tile grid around default center
    center_x, center_y = DEFAULT_CENTER
    center_tile_col, center_tile_row = epsg3978_to_tile(center_x, center_y, zoom)
    
    # Calculate tile bounds for map coverage
    tiles_wide, tiles_high = map_size
    start_tile_col = center_tile_col - tiles_wide // 2
    start_tile_row = center_tile_row - tiles_high // 2
    
    click.echo(f"Downloading {tiles_wide}x{tiles_high} tiles centered on tile {center_tile_col},{center_tile_row}")
    click.echo(f"Tile range: col {start_tile_col} to {start_tile_col + tiles_wide - 1}, row {start_tile_row} to {start_tile_row + tiles_high - 1}")
    
    # Prepare all tile requests upfront
    tile_requests = []
    for row_idx in range(tiles_high):
        for col_idx in range(tiles_wide):
            tile_col = start_tile_col + col_idx
            tile_row = start_tile_row + row_idx
            bbox = tile_to_epsg3978_bbox(tile_col, tile_row, zoom)
            
            tile_info = TileInfo(
                col=tile_col,
                row=tile_row,
                zoom=zoom,
                bbox=bbox,
                paste_x=col_idx * TILE_SIZE,
                paste_y=row_idx * TILE_SIZE,
                image_pos=(col_idx+1, row_idx+1)
            )
            tile_requests.append(tile_info)
    
    # Create final image
    final_width = tiles_wide * TILE_SIZE
    final_height = tiles_high * TILE_SIZE
    final_image = Image.new('RGB', (final_width, final_height))
    
    # Configure connection limits for server kindness
    connector = aiohttp.TCPConnector(
        limit=100,           # Total connection pool size
        limit_per_host=8,    # Max connections per host
        ttl_dns_cache=300    # DNS cache TTL
    )
    
    # Download all tiles concurrently
    async with aiohttp.ClientSession(connector=connector) as session:
        click.echo("Starting concurrent downloads...")
        
        # Download base tiles and fire overlays concurrently
        base_tasks = [download_base_tile_async(session, tile_info) for tile_info in tile_requests]
        
        # If year_range is specified, download fire overlays for all years
        if year_range:
            start_year, end_year = year_range
            all_fire_results = []
            for year in range(start_year, end_year + 1):
                # Create a date with the current year but same month/day
                year_date = date.replace(year=year)
                fire_tasks = [download_fire_overlay_async(session, tile_info, year_date, year_range) for tile_info in tile_requests]
                fire_results = await asyncio.gather(*fire_tasks)
                all_fire_results.append(fire_results)
        else:
            fire_tasks = [download_fire_overlay_async(session, tile_info, date) for tile_info in tile_requests]
            fire_results = await asyncio.gather(*fire_tasks)
            all_fire_results = [fire_results]
        
        # Wait for all downloads to complete (maintains order!)
        base_results = await asyncio.gather(*base_tasks)
    
    # Composite results in order
    click.echo("Compositing tiles...")
    for idx, (tile_info, base_tile) in enumerate(base_results):
        click.echo(f"  -> Placing tile col={tile_info.col}, row={tile_info.row} at position {tile_info.paste_x},{tile_info.paste_y}")
        
        # Start with base tile
        composite = base_tile.convert('RGBA')
        
        # Layer all fire overlays for this tile
        for fire_results in all_fire_results:
            _, fire_overlay = fire_results[idx]
            if fire_overlay.mode == 'RGBA':
                composite = Image.alpha_composite(composite, fire_overlay)
        
        # Convert back to RGB
        composite = composite.convert('RGB')
        
        # Place in final image
        final_image.paste(composite, (tile_info.paste_x, tile_info.paste_y))
    
    # Add date overlay if requested
    if date_overlay:
        click.echo("Adding date overlay...")
        final_image = add_date_overlay(final_image, date, year_range)
    
    # Save final image
    final_image.save(output_path, 'PNG', optimize=True)
    click.echo(f"Wildfire map saved to: {output_path}")
    click.echo(f"Image size: {final_width}x{final_height} pixels")


def generate_date_range(start_date: datetime, end_date: datetime, output_dir: Path, zoom: int, map_size: tuple[int, int], date_overlay: bool) -> None:
    """Generate wildfire maps for a date range sequentially."""
    # Check if this is a multi-year span
    if start_date.year != end_date.year:
        # Multi-year mode: create daily images for the month/day range with all years overlaid
        start_year = start_date.year
        end_year = end_date.year
        year_range = (start_year, end_year)
        
        # Use the start date's month/day to end date's month/day
        # Create a reference year (use start year) to iterate through days
        ref_start = start_date
        ref_end = start_date.replace(month=end_date.month, day=end_date.day)
        
        # If ref_end is before ref_start, it means we're spanning across a year boundary
        # In this case, we should only generate images for the days in the range
        if ref_end < ref_start:
            click.echo(f"Error: Multi-year mode requires end date to have same or later month/day as start date", err=True)
            sys.exit(1)
        
        num_days = (ref_end - ref_start).days + 1
        
        click.echo("Generating multi-year wildfire maps...")
        click.echo(f"Year range: {start_year} to {end_year}")
        click.echo(f"Date range: {ref_start.strftime('%m-%d')} to {ref_end.strftime('%m-%d')}")
        click.echo(f"Number of days: {num_days}")
        click.echo(f"Output directory: {output_dir}")
        click.echo("")
        
        # Generate maps for each day with all years overlaid
        for i in range(num_days):
            current_date = ref_start + timedelta(days=i)
            progress = i + 1
            
            click.echo(f"[{progress}/{num_days}] Generating multi-year map for {current_date.strftime('%m-%d')}...")
            
            # Create filename with year range
            filename = f"wildfire-{start_year}-{end_year}-{current_date.strftime('%m-%d')}-z{zoom}-{map_size[0]}x{map_size[1]}.png"
            output_path = output_dir / filename
            
            try:
                # Generate the map with year range
                asyncio.run(create_wildfire_map(current_date, output_path, zoom, map_size, date_overlay, year_range))
                click.echo(f"  ✓ Saved: {output_path}")
                click.echo("")
            except Exception as e:
                click.echo(f"  ✗ Failed to generate map for {current_date.strftime('%m-%d')}: {e}", err=True)
                sys.exit(1)
        
        click.echo(f"🎉 All {num_days} multi-year wildfire maps generated successfully!")
        click.echo(f"Year range: {start_year} to {end_year}")
        click.echo(f"Date range: {ref_start.strftime('%m-%d')} to {ref_end.strftime('%m-%d')}")
        click.echo(f"Location: {output_dir}")
        return
    
    # Single year mode (existing behavior)
    # Calculate number of days
    num_days = (end_date - start_date).days + 1
    
    click.echo("Generating wildfire maps...")
    click.echo(f"Start date: {start_date.strftime('%Y-%m-%d')}")
    click.echo(f"End date: {end_date.strftime('%Y-%m-%d')}")
    click.echo(f"Number of days: {num_days}")
    click.echo(f"Output directory: {output_dir}")
    click.echo("")
    
    # Generate maps for each day
    for i in range(num_days):
        current_date = start_date + timedelta(days=i)
        progress = i + 1
        
        click.echo(f"[{progress}/{num_days}] Generating map for {current_date.strftime('%Y-%m-%d')}...")
        
        # Create filename
        filename = f"wildfire-{current_date.strftime('%Y-%m-%d')}-z{zoom}-{map_size[0]}x{map_size[1]}.png"
        output_path = output_dir / filename
        
        try:
            # Generate the map
            asyncio.run(create_wildfire_map(current_date, output_path, zoom, map_size, date_overlay, year_range=None))
            click.echo(f"  ✓ Saved: {output_path}")
            click.echo("")
        except Exception as e:
            click.echo(f"  ✗ Failed to generate map for {current_date.strftime('%Y-%m-%d')}: {e}", err=True)
            sys.exit(1)  # Stop on error as requested
    
    click.echo(f"🎉 All {num_days} wildfire maps generated successfully!")
    click.echo(f"Date range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
    click.echo(f"Location: {output_dir}")


@click.command()
@click.argument('start_date', callback=lambda ctx, param, value: validate_date(value))
@click.argument('end_date', required=False, callback=lambda ctx, param, value: validate_date(value) if value else None)
@click.option('--output', '-o', type=click.Path(), help='Output directory (default: current directory)')
@click.option('--zoom', '-z', type=int, default=DEFAULT_ZOOM, help=f'Zoom level (0-{len(RESOLUTIONS)-1}, default: {DEFAULT_ZOOM})')
@click.option('--width', '-w', type=int, default=MAP_SIZE[0], help=f'Map width in tiles (default: {MAP_SIZE[0]})')
@click.option('--height', '-h', type=int, default=MAP_SIZE[1], help=f'Map height in tiles (default: {MAP_SIZE[1]})')
@click.option('--date-overlay/--no-date-overlay', default=True, help='Add date overlay to upper right corner (default: enabled)')
def main(start_date: datetime, end_date: datetime = None, output: str = None, zoom: int = DEFAULT_ZOOM, width: int = MAP_SIZE[0], height: int = MAP_SIZE[1], date_overlay: bool = True) -> None:
    """
    Download Canadian wildfire map for a given date or date range.
    
    \b
    START_DATE: Starting date in YYYY-MM-DD format (e.g., 2025-08-04)
    END_DATE: Optional ending date for range (e.g., 2025-08-07)
    
    \b
    Multi-year overlay mode:
    When START_DATE and END_DATE span different years, creates daily images
    with fire polygons from all years overlaid. For example:
    - wildfire 2024-08-01 2025-08-04 creates 4 images (Aug 1-4)
    - Each image shows fires from both 2024 and 2025 for that day
    - Date overlay shows "2024-2025 08-01" format
    - Files named like "wildfire-2024-2025-08-01-z6-9x4.png"
    
    \b
    Examples:
        wildfire 2025-08-04                           # Single date
        wildfire 2025-08-01 2025-08-04                # Date range (single year)
        wildfire 2024-08-01 2025-08-04                # Multi-year overlay mode
        wildfire 2025-08-04 -z 5 -w 5 -h 4           # Custom zoom and size
        wildfire 2025-08-04 --no-date-overlay         # Disable date overlay
        wildfire 2025-04-01 2025-08-04 -o 2025        # Range to directory
    """
    # Validate parameters
    if zoom < 0 or zoom >= len(RESOLUTIONS):
        click.echo(f"Error: Zoom level must be between 0 and {len(RESOLUTIONS)-1}, got {zoom}", err=True)
        sys.exit(1)
    
    if width < 1 or width > 10:
        click.echo(f"Error: Width must be between 1 and 10 tiles, got {width}", err=True)
        sys.exit(1)
    
    if height < 1 or height > 10:
        click.echo(f"Error: Height must be between 1 and 10 tiles, got {height}", err=True)
        sys.exit(1)
    
    # Validate date range if end_date is provided
    if end_date is not None and end_date < start_date:
        click.echo(f"Error: End date '{end_date.strftime('%Y-%m-%d')}' must be after start date '{start_date.strftime('%Y-%m-%d')}'.", err=True)
        sys.exit(1)
    
    # Set up output directory
    if output is None:
        output_dir = Path(".")
    else:
        output_dir = Path(output)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    try:
        if end_date is None:
            # Single date mode
            filename = f"wildfire-{start_date.strftime('%Y-%m-%d')}-z{zoom}-{width}x{height}.png"
            output_path = output_dir / filename
            asyncio.run(create_wildfire_map(start_date, output_path, zoom, (width, height), date_overlay, year_range=None))
        else:
            # Date range mode
            generate_date_range(start_date, end_date, output_dir, zoom, (width, height), date_overlay)
    except KeyboardInterrupt:
        click.echo("\nOperation cancelled by user", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)

if __name__ == '__main__':
    main()